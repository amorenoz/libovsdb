package main

import (
	"encoding/json"
	"testing"

	"github.com/ovn-org/libovsdb/ovsdb"
	"github.com/stretchr/testify/assert"
)

func TestNewTableGenerator(t *testing.T) {
	rawSchema := []byte(`
	{
		"name": "AtomicDB",
		"version": "0.0.0",
		"tables": {
			"atomicTable": {
				"columns": {
					"str": {
						"type": "string"
					},
					"int": {
						"type": "integer"
					},
					"float": {
						"type": "real"
					}
				}
			}
		}
	}`)

	expected := `// Code generated by modelgen ` + version + ` (github.com/ovn-org/libovsdb/cmd/modelgen)
// DO NOT EDIT.

package test

// test defines an object in test table
type test struct {
	UUID  string  ` + "`" + `ovs:"_uuid"` + "`" + `
	Float float64 ` + "`" + `ovs:"float"` + "`" + `
	Int   int     ` + "`" + `ovs:"int"` + "`" + `
	Str   string  ` + "`" + `ovs:"str"` + "`" + `
}
`

	var schema ovsdb.DatabaseSchema
	err := json.Unmarshal(rawSchema, &schema)
	if err != nil {
		t.Fatal(err)
	}
	table := schema.Tables["atomicTable"]
	gen := NewTableGenerator(
		"test",
		"test",
		&table,
	)

	for i := 0; i < 3; i++ {
		b, err := gen.Format()
		if err != nil {
			t.Fatal(err)
		}
		assert.Equal(t, expected, string(b))
	}
}

func TestFieldName(t *testing.T) {
	cases := []struct {
		in       string
		expected string
	}{
		{"foo", "Foo"},
	}
	for _, tt := range cases {
		if s := FieldName(tt.in); s != tt.expected {
			t.Fatalf("got %s, wanted %s", s, tt.expected)
		}
	}

}

func TestStructName(t *testing.T) {
	if s := StructName("Foo_Bar"); s != "FooBar" {
		t.Fatalf("got %s, wanted FooBar", s)
	}
}

/*
TODO: Write Test
func TestFieldType(t *testing.T) {
	tests := []struct {
		name string
		in   *ovsdb.ColumnSchema
		out  string
	}
	if got := FieldType(tt.args.column); got != tt.want {
		t.Errorf("FieldType() = %v, want %v", got, tt.want)
	}
}
*/

func TestAtomicType(t *testing.T) {
	tests := []struct {
		name string
		in   string
		out  string
	}{
		{"IntegerToInt", ovsdb.TypeInteger, "int"},
		{"RealToFloat", ovsdb.TypeReal, "float64"},
		{"BooleanToBool", ovsdb.TypeBoolean, "bool"},
		{"StringToString", ovsdb.TypeString, "string"},
		{"UUIDToString", ovsdb.TypeUUID, "string"},
		{"Invalid", "notAType", ""},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := AtomicType(tt.in); got != tt.out {
				t.Errorf("got %s, wanted %s", got, tt.out)
			}
		})
	}
}

func TestTag(t *testing.T) {
	if s := Tag("Foo_Bar"); s != "`ovs:\"Foo_Bar\"`" {
		t.Fatalf("got %s, wanted `ovs:\"Foo_Bar\"`", s)
	}
}

func TestFileName(t *testing.T) {
	if s := FileName("foo"); s != "foo.go" {
		t.Fatalf("got %s, wanted foo.go", s)
	}
}

func TestCamelCase(t *testing.T) {
	cases := []struct {
		in       string
		expected string
	}{
		{"foo_bar_baz", "FooBarBaz"},
		{"foo-bar-baz", "FooBarBaz"},
		{"foos-bars-bazs", "FoosBarsBazs"},
		{"ip_port_mappings", "IPPortMappings"},
		{"external_ids", "ExternalIDs"},
		{"ip_prefix", "IPPrefix"},
		{"dns_records", "DNSRecords"},
		{"logical_ip", "LogicalIP"},
		{"ip", "IP"},
	}
	for _, tt := range cases {
		if s := camelCase(tt.in); s != tt.expected {
			t.Fatalf("got %s, wanted %s", s, tt.expected)
		}
	}
}
